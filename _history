{"entries":[{"timestamp":1746022042955,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":1686,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":210,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1746022577880,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":299,"length1":0,"diffs":[[1,"let pingMessage = false;\n"]]},{"start1":325,"length1":1,"diffs":[[1,""]]},{"start1":1685,"length1":4475,"diffs":[[1,"}"]]}]}]},{"timestamp":1746628592833,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]}]},{"timestamp":1746643448698,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":210,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1746022042954,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Pong com IA\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1746040677955,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"const BALL_IMAGE = img`\n    . . e e 1 e e e . .\n    . e 1 1 d d d d e .\n    e 1 d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    . e d d d d d d e .\n    . . e e e e e e . .\n`;\n\nconst PADDLE_SPEED = 150;\nconst PADDING_FROM_WALL = 3;\n\n\n// if player doesn't interact for 'TIMEOUT' time, revert to ai\nconst TIMEOUT = 5000;\nlet playerOneLastMove = -TIMEOUT;\nlet playerTwoLastMove = -TIMEOUT;\n\ncontroller.setRepeatDefault(0, 1000);\n\ncontroller.up.onEvent(ControllerButtonEvent.Repeated, () => playerOneLastMove = game.runtime());\ncontroller.down.onEvent(ControllerButtonEvent.Repeated, () => playerOneLastMove = game.runtime());\ncontroller.player2.up.onEvent(ControllerButtonEvent.Repeated, () => playerTwoLastMove = game.runtime());\ncontroller.player2.down.onEvent(ControllerButtonEvent.Repeated, () => playerTwoLastMove = game.runtime());\n\nconst playerOne = createPlayer(info.player1);\nplayerOne.left = PADDING_FROM_WALL;\ncontroller.moveSprite(playerOne, 0, PADDLE_SPEED);\n\nconst playerTwo = createPlayer(info.player2);\nplayerTwo.right = screen.width - PADDING_FROM_WALL;\ncontroller.player2.moveSprite(playerTwo, 0, PADDLE_SPEED);\n\ncreateBall();\n\nfunction createPlayer(player: info.PlayerInfo) {\n    const output = sprites.create(image.create(3, 18), SpriteKind.Player);\n\n    output.image.fill(player.bg);\n    output.setStayInScreen(true);\n\n    player.setScore(0);\n    player.showPlayer = false;\n\n    return output;\n}\n\nfunction createBall() {\n    let ball = sprites.create(BALL_IMAGE.clone(), SpriteKind.Enemy);\n    ball.vy = randint(-20, 20);\n    ball.vx = 60 * (Math.percentChance(50) ? 1 : -1);\n}\n\ngame.onUpdate(function () {\n    sprites\n        .allOfKind(SpriteKind.Enemy)\n        .forEach(b => {\n            const scoreRight = b.x < 0;\n            const scoreLeft = b.x >= screen.width;\n\n            if (scoreRight) {\n                info.player2.changeScoreBy(1)\n            } else if (scoreLeft) {\n                info.player1.changeScoreBy(1)\n            }\n\n            if (b.top < 0) {\n                b.vy = Math.abs(b.vy);\n            } else if (b.bottom > screen.height) {\n                b.vy = -Math.abs(b.vy);\n            }\n\n            if (scoreLeft || scoreRight) {\n                b.destroy(effects.disintegrate, 500);\n                control.runInParallel(function () {\n                    pause(250);\n                    createBall();\n                });\n            }\n        }\n        );\n});\n\n\n\nsprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy,\n    (sprite: Sprite, otherSprite: Sprite) => {\n        const fromCenter = otherSprite.y - sprite.y;\n\n        otherSprite.vx = otherSprite.vx * -1.05;\n        otherSprite.vy += (sprite.vy >> 1) + (fromCenter * 3);\n\n        otherSprite.startEffect(effects.ashes, 150);\n        sprite.startEffect(effects.ashes, 100);\n\n        otherSprite.image.setPixel(\n            randint(1, otherSprite.image.width - 2),\n            randint(1, otherSprite.image.height - 2),\n            sprite.image.getPixel(0, 0)\n        );\n\n      \n\n        // time out this event so it doesn't retrigger on the same collision\n        pause(500);\n    }\n);\n\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, () => addBall(info.player1));\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, () => removeBall(info.player1));\ncontroller.player2.A.onEvent(ControllerButtonEvent.Pressed, () => addBall(info.player2));\ncontroller.player2.B.onEvent(ControllerButtonEvent.Pressed, () => removeBall(info.player2));\n\nfunction addBall(player: info.PlayerInfo) {\n    player.changeScoreBy(-2);\n    createBall();\n}\n\nfunction removeBall(player: info.PlayerInfo) {\n    const balls = sprites.allOfKind(SpriteKind.Enemy);\n    if (balls.length > 1) {\n        Math.pickRandom(balls).destroy();\n        player.changeScoreBy(-2);\n    }\n}\n\ngame.onUpdate(function () {\n    const currTime = game.runtime();\n\n    if (playerOneLastMove + TIMEOUT < currTime) {\n        trackBall(playerOne);\n    }\n\n    if (playerTwoLastMove + TIMEOUT < currTime) {\n        trackBall(playerTwo);\n    }\n\n    function trackBall(player: Sprite) {\n        const next = nextBall(player);\n        if (!next)\n            return;\n        if (ballFacingPlayer(player, next)) {\n            // move to where ball is expected to intersect\n            intersectBall(player, next);\n        } else {\n            // relax, ball is going other way\n            player.vy = 0;\n        }\n    }\n\n    function nextBall(player: Sprite) {\n        return sprites\n            .allOfKind(SpriteKind.Enemy)\n            .sort((a, b) => {\n                const aFacingPlayer = ballFacingPlayer(player, a);\n                const bFacingPlayer = ballFacingPlayer(player, b);\n\n                // else prefer ball facing player\n                if (aFacingPlayer && !bFacingPlayer) return -1;\n                else if (!aFacingPlayer && bFacingPlayer) return 1;\n\n                // else prefer ball that will next reach player\n                const aDiff = Math.abs((a.x - player.x) / a.vx);\n                const bDiff = Math.abs((b.x - player.x) / b.vx);\n                return aDiff - bDiff;\n            })[0];\n    }\n\n    function ballFacingPlayer(player: Sprite, ball: Sprite) {\n        return (ball.vx < 0 && player.x < 80) || (ball.vx > 0 && player.x > 80);\n    }\n\n    function intersectBall(player: Sprite, target: Sprite) {\n        const projectedDY = (target.x - player.x) * target.vy / target.vx;\n        let intersectionPoint = target.y - projectedDY;\n\n        // quick 'estimation' for vertical bounces\n        if (intersectionPoint < 0) {\n            intersectionPoint = Math.abs(intersectionPoint % screen.height)\n        } else if (intersectionPoint > screen.height) {\n            intersectionPoint -= intersectionPoint % screen.height;\n        }\n\n        // move toward estimated intersection point if not in range\n        if (intersectionPoint > player.y + (player.height >> 2)) {\n            player.vy = PADDLE_SPEED;\n        } else if (intersectionPoint < player.y - (player.height >> 2)) {\n            player.vy = -PADDLE_SPEED;\n        } else {\n            player.vy = 0;\n        }\n    }\n});","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Pong com IA\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746628592833,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"const BALL_IMAGE = img`\n    . . e e 1 e e e . .\n    . e 1 1 d d d d e .\n    e 1 d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    . e d d d d d d e .\n    . . e e e e e e . .\n`;\n\nconst PADDLE_SPEED = 150;\nconst PADDING_FROM_WALL = 3;\n\n\n// if player doesn't interact for 'TIMEOUT' time, revert to ai\nconst TIMEOUT = 5000;\nlet playerOneLastMove = -TIMEOUT;\nlet playerTwoLastMove = -TIMEOUT;\n\ncontroller.setRepeatDefault(0, 1000);\n\ncontroller.up.onEvent(ControllerButtonEvent.Repeated, () => playerOneLastMove = game.runtime());\ncontroller.down.onEvent(ControllerButtonEvent.Repeated, () => playerOneLastMove = game.runtime());\ncontroller.player2.up.onEvent(ControllerButtonEvent.Repeated, () => playerTwoLastMove = game.runtime());\ncontroller.player2.down.onEvent(ControllerButtonEvent.Repeated, () => playerTwoLastMove = game.runtime());\n\nconst playerOne = createPlayer(info.player1);\nplayerOne.left = PADDING_FROM_WALL;\ncontroller.moveSprite(playerOne, 0, PADDLE_SPEED);\n\nconst playerTwo = createPlayer(info.player2);\nplayerTwo.right = screen.width - PADDING_FROM_WALL;\ncontroller.player2.moveSprite(playerTwo, 0, PADDLE_SPEED);\n\ncreateBall();\n\nfunction createPlayer(player: info.PlayerInfo) {\n    const output = sprites.create(image.create(3, 18), SpriteKind.Player);\n\n    output.image.fill(player.bg);\n    output.setStayInScreen(true);\n\n    player.setScore(0);\n    player.showPlayer = false;\n\n    return output;\n}\n\nfunction createBall() {\n    let ball = sprites.create(BALL_IMAGE.clone(), SpriteKind.Enemy);\n    ball.vy = randint(-20, 20);\n    ball.vx = 60 * (Math.percentChance(50) ? 1 : -1);\n}\n\ngame.onUpdate(function () {\n    sprites\n        .allOfKind(SpriteKind.Enemy)\n        .forEach(b => {\n            const scoreRight = b.x < 0;\n            const scoreLeft = b.x >= screen.width;\n\n            if (scoreRight) {\n                info.player2.changeScoreBy(1)\n            } else if (scoreLeft) {\n                info.player1.changeScoreBy(1)\n            }\n\n            if (b.top < 0) {\n                b.vy = Math.abs(b.vy);\n            } else if (b.bottom > screen.height) {\n                b.vy = -Math.abs(b.vy);\n            }\n\n            if (scoreLeft || scoreRight) {\n                b.destroy(effects.disintegrate, 500);\n                control.runInParallel(function () {\n                    pause(250);\n                    createBall();\n                });\n            }\n        }\n        );\n});\n\n\n\nsprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy,\n    (sprite: Sprite, otherSprite: Sprite) => {\n        const fromCenter = otherSprite.y - sprite.y;\n\n        otherSprite.vx = otherSprite.vx * -1.05;\n        otherSprite.vy += (sprite.vy >> 1) + (fromCenter * 3);\n\n        otherSprite.startEffect(effects.ashes, 150);\n        sprite.startEffect(effects.ashes, 100);\n\n        otherSprite.image.setPixel(\n            randint(1, otherSprite.image.width - 2),\n            randint(1, otherSprite.image.height - 2),\n            sprite.image.getPixel(0, 0)\n        );\n\n      \n\n        // time out this event so it doesn't retrigger on the same collision\n        pause(500);\n    }\n);\n\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, () => addBall(info.player1));\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, () => removeBall(info.player1));\ncontroller.player2.A.onEvent(ControllerButtonEvent.Pressed, () => addBall(info.player2));\ncontroller.player2.B.onEvent(ControllerButtonEvent.Pressed, () => removeBall(info.player2));\n\nfunction addBall(player: info.PlayerInfo) {\n    player.changeScoreBy(-2);\n    createBall();\n}\n\nfunction removeBall(player: info.PlayerInfo) {\n    const balls = sprites.allOfKind(SpriteKind.Enemy);\n    if (balls.length > 1) {\n        Math.pickRandom(balls).destroy();\n        player.changeScoreBy(-2);\n    }\n}\n\ngame.onUpdate(function () {\n    const currTime = game.runtime();\n\n    if (playerOneLastMove + TIMEOUT < currTime) {\n        trackBall(playerOne);\n    }\n\n    if (playerTwoLastMove + TIMEOUT < currTime) {\n        trackBall(playerTwo);\n    }\n\n    function trackBall(player: Sprite) {\n        const next = nextBall(player);\n        if (!next)\n            return;\n        if (ballFacingPlayer(player, next)) {\n            // move to where ball is expected to intersect\n            intersectBall(player, next);\n        } else {\n            // relax, ball is going other way\n            player.vy = 0;\n        }\n    }\n\n    function nextBall(player: Sprite) {\n        return sprites\n            .allOfKind(SpriteKind.Enemy)\n            .sort((a, b) => {\n                const aFacingPlayer = ballFacingPlayer(player, a);\n                const bFacingPlayer = ballFacingPlayer(player, b);\n\n                // else prefer ball facing player\n                if (aFacingPlayer && !bFacingPlayer) return -1;\n                else if (!aFacingPlayer && bFacingPlayer) return 1;\n\n                // else prefer ball that will next reach player\n                const aDiff = Math.abs((a.x - player.x) / a.vx);\n                const bDiff = Math.abs((b.x - player.x) / b.vx);\n                return aDiff - bDiff;\n            })[0];\n    }\n\n    function ballFacingPlayer(player: Sprite, ball: Sprite) {\n        return (ball.vx < 0 && player.x < 80) || (ball.vx > 0 && player.x > 80);\n    }\n\n    function intersectBall(player: Sprite, target: Sprite) {\n        const projectedDY = (target.x - player.x) * target.vy / target.vx;\n        let intersectionPoint = target.y - projectedDY;\n\n        // quick 'estimation' for vertical bounces\n        if (intersectionPoint < 0) {\n            intersectionPoint = Math.abs(intersectionPoint % screen.height)\n        } else if (intersectionPoint > screen.height) {\n            intersectionPoint -= intersectionPoint % screen.height;\n        }\n\n        // move toward estimated intersection point if not in range\n        if (intersectionPoint > player.y + (player.height >> 2)) {\n            player.vy = PADDLE_SPEED;\n        } else if (intersectionPoint < player.y - (player.height >> 2)) {\n            player.vy = -PADDLE_SPEED;\n        } else {\n            player.vy = 0;\n        }\n    }\n});","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Pong com IA\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1746643448698,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"const BALL_IMAGE = img`\n    . . e e 1 e e e . .\n    . e 1 1 d d d d e .\n    e 1 d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    e d d d d d d d d e\n    . e d d d d d d e .\n    . . e e e e e e . .\n`;\n\nconst PADDLE_SPEED = 150;\nconst PADDING_FROM_WALL = 3;\n\n\n// if player doesn't interact for 'TIMEOUT' time, revert to ai\nconst TIMEOUT = 5000;\nlet playerOneLastMove = -TIMEOUT;\nlet playerTwoLastMove = -TIMEOUT;\n\ncontroller.setRepeatDefault(0, 1000);\n\ncontroller.up.onEvent(ControllerButtonEvent.Repeated, () => playerOneLastMove = game.runtime());\ncontroller.down.onEvent(ControllerButtonEvent.Repeated, () => playerOneLastMove = game.runtime());\ncontroller.player2.up.onEvent(ControllerButtonEvent.Repeated, () => playerTwoLastMove = game.runtime());\ncontroller.player2.down.onEvent(ControllerButtonEvent.Repeated, () => playerTwoLastMove = game.runtime());\n\nconst playerOne = createPlayer(info.player1);\nplayerOne.left = PADDING_FROM_WALL;\ncontroller.moveSprite(playerOne, 0, PADDLE_SPEED);\n\nconst playerTwo = createPlayer(info.player2);\nplayerTwo.right = screen.width - PADDING_FROM_WALL;\ncontroller.player2.moveSprite(playerTwo, 0, PADDLE_SPEED);\n\ncreateBall();\n\nfunction createPlayer(player: info.PlayerInfo) {\n    const output = sprites.create(image.create(3, 18), SpriteKind.Player);\n\n    output.image.fill(player.bg);\n    output.setStayInScreen(true);\n\n    player.setScore(0);\n    player.showPlayer = false;\n\n    return output;\n}\n\nfunction createBall() {\n    let ball = sprites.create(BALL_IMAGE.clone(), SpriteKind.Enemy);\n    ball.vy = randint(-20, 20);\n    ball.vx = 60 * (Math.percentChance(50) ? 1 : -1);\n}\n\ngame.onUpdate(function () {\n    sprites\n        .allOfKind(SpriteKind.Enemy)\n        .forEach(b => {\n            const scoreRight = b.x < 0;\n            const scoreLeft = b.x >= screen.width;\n\n            if (scoreRight) {\n                info.player2.changeScoreBy(1)\n            } else if (scoreLeft) {\n                info.player1.changeScoreBy(1)\n            }\n\n            if (b.top < 0) {\n                b.vy = Math.abs(b.vy);\n            } else if (b.bottom > screen.height) {\n                b.vy = -Math.abs(b.vy);\n            }\n\n            if (scoreLeft || scoreRight) {\n                b.destroy(effects.disintegrate, 500);\n                control.runInParallel(function () {\n                    pause(250);\n                    createBall();\n                });\n            }\n        }\n        );\n});\n\n\n\nsprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy,\n    (sprite: Sprite, otherSprite: Sprite) => {\n        const fromCenter = otherSprite.y - sprite.y;\n\n        otherSprite.vx = otherSprite.vx * -1.05;\n        otherSprite.vy += (sprite.vy >> 1) + (fromCenter * 3);\n\n        otherSprite.startEffect(effects.ashes, 150);\n        sprite.startEffect(effects.ashes, 100);\n\n        otherSprite.image.setPixel(\n            randint(1, otherSprite.image.width - 2),\n            randint(1, otherSprite.image.height - 2),\n            sprite.image.getPixel(0, 0)\n        );\n\n      \n\n        // time out this event so it doesn't retrigger on the same collision\n        pause(500);\n    }\n);\n\ncontroller.A.onEvent(ControllerButtonEvent.Pressed, () => addBall(info.player1));\ncontroller.B.onEvent(ControllerButtonEvent.Pressed, () => removeBall(info.player1));\ncontroller.player2.A.onEvent(ControllerButtonEvent.Pressed, () => addBall(info.player2));\ncontroller.player2.B.onEvent(ControllerButtonEvent.Pressed, () => removeBall(info.player2));\n\nfunction addBall(player: info.PlayerInfo) {\n    player.changeScoreBy(-2);\n    createBall();\n}\n\nfunction removeBall(player: info.PlayerInfo) {\n    const balls = sprites.allOfKind(SpriteKind.Enemy);\n    if (balls.length > 1) {\n        Math.pickRandom(balls).destroy();\n        player.changeScoreBy(-2);\n    }\n}\n\ngame.onUpdate(function () {\n    const currTime = game.runtime();\n\n    if (playerOneLastMove + TIMEOUT < currTime) {\n        trackBall(playerOne);\n    }\n\n    if (playerTwoLastMove + TIMEOUT < currTime) {\n        trackBall(playerTwo);\n    }\n\n    function trackBall(player: Sprite) {\n        const next = nextBall(player);\n        if (!next)\n            return;\n        if (ballFacingPlayer(player, next)) {\n            // move to where ball is expected to intersect\n            intersectBall(player, next);\n        } else {\n            // relax, ball is going other way\n            player.vy = 0;\n        }\n    }\n\n    function nextBall(player: Sprite) {\n        return sprites\n            .allOfKind(SpriteKind.Enemy)\n            .sort((a, b) => {\n                const aFacingPlayer = ballFacingPlayer(player, a);\n                const bFacingPlayer = ballFacingPlayer(player, b);\n\n                // else prefer ball facing player\n                if (aFacingPlayer && !bFacingPlayer) return -1;\n                else if (!aFacingPlayer && bFacingPlayer) return 1;\n\n                // else prefer ball that will next reach player\n                const aDiff = Math.abs((a.x - player.x) / a.vx);\n                const bDiff = Math.abs((b.x - player.x) / b.vx);\n                return aDiff - bDiff;\n            })[0];\n    }\n\n    function ballFacingPlayer(player: Sprite, ball: Sprite) {\n        return (ball.vx < 0 && player.x < 80) || (ball.vx > 0 && player.x > 80);\n    }\n\n    function intersectBall(player: Sprite, target: Sprite) {\n        const projectedDY = (target.x - player.x) * target.vy / target.vx;\n        let intersectionPoint = target.y - projectedDY;\n\n        // quick 'estimation' for vertical bounces\n        if (intersectionPoint < 0) {\n            intersectionPoint = Math.abs(intersectionPoint % screen.height)\n        } else if (intersectionPoint > screen.height) {\n            intersectionPoint -= intersectionPoint % screen.height;\n        }\n\n        // move toward estimated intersection point if not in range\n        if (intersectionPoint > player.y + (player.height >> 2)) {\n            player.vy = PADDLE_SPEED;\n        } else if (intersectionPoint < player.y - (player.height >> 2)) {\n            player.vy = -PADDLE_SPEED;\n        } else {\n            player.vy = 0;\n        }\n    }\n});","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"Pong com IA\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[{"id":"50167-73779-42388-84698","timestamp":1746022695376},{"id":"43494-50294-31196-75919","timestamp":1746641470277},{"id":"17379-17574-57446-98024","timestamp":1746641644215}],"lastSaveTime":1746643448703}